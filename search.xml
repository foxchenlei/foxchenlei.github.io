<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>jenkins与gitlab整合</title>
    <url>/2018/07/09/2018-07-09-jenkins-gitlab-webhook/</url>
    <content><![CDATA[<h1 id="1、环境说明"><a href="#1、环境说明" class="headerlink" title="1、环境说明"></a>1、环境说明</h1><p>jenkins: 2.68</p>
<p>gitlab : 10.1.1</p>
<p>tomcat ：6.0.18</p>
<p><strong>注意：不同版本gitlab，配置webhook方式有差异，这里只展示当前版本</strong></p>
<a id="more"></a>

<h1 id="2、相关依赖包"><a href="#2、相关依赖包" class="headerlink" title="2、相关依赖包"></a>2、相关依赖包</h1><p>该功能需要jenkins 安装插件Gitlab Hook Plugin</p>
<h2 id="2-1-jenkins在安装gitlab-hook-plugins提示失败"><a href="#2-1-jenkins在安装gitlab-hook-plugins提示失败" class="headerlink" title="2.1 jenkins在安装gitlab hook plugins提示失败:"></a>2.1 jenkins在安装gitlab hook plugins提示失败:</h2><p>问题 : gitlab hook plugin无法安装的原因是因为ruby-runtime无法安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.io.IOException: Failed to dynamically deploy this plugin</span><br><span class="line">at hudson.model.UpdateCenter$InstallationJob._run(UpdateCenter.java:1328)</span><br><span class="line">at hudson.model.UpdateCenter$DownloadJob.run(UpdateCenter.java:1126)</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">at hudson.remoting.AtmostOneThreadExecutor$Worker.run(AtmostOneThreadExecutor.java:110)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">Caused by: java.io.IOException: Failed to install ruby-runtime plugin</span><br><span class="line">at hudson.PluginManager.dynamicLoad(PluginManager.java:487)</span><br><span class="line">at hudson.model.UpdateCenter$InstallationJob._run(UpdateCenter.java:1324)</span><br><span class="line">... 5 more</span><br><span class="line">Caused by: java.io.IOException: Failed to initialize</span><br><span class="line">at hudson.ClassicPluginStrategy.load(ClassicPluginStrategy.java:441)</span><br><span class="line">at hudson.PluginManager.dynamicLoad(PluginManager.java:478)</span><br><span class="line">... 6 more</span><br><span class="line">Caused by: java.lang.ClassCircularityError: org&#x2F;jruby&#x2F;RubyClass</span><br><span class="line">at java.lang.Class.forName0(Native Method)</span><br><span class="line">at java.lang.Class.forName(Class.java:348)</span><br></pre></td></tr></table></figure>

<p>这是官方issue <a href="https://issues.jenkins-ci.org/browse/JENKINS-31019" target="_blank" rel="noopener">https://issues.jenkins-ci.org/browse/JENKINS-31019</a></p>
<p>处理方式：给jenkins的启动容器添加JAVA_OPTIONS，我这里是tomcat，所以添加JAVA_OPTS到catalina.sh</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS&#x3D;&quot;-Djava.awt.headless&#x3D;true -Dhudson.ClassicPluginStrategy.noBytecodeTransformer&#x3D;true&quot;</span><br></pre></td></tr></table></figure>

<h1 id="3、配置gitlab认证"><a href="#3、配置gitlab认证" class="headerlink" title="3、配置gitlab认证"></a>3、配置gitlab认证</h1><img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/1.png" class="">

<p>添加一个新的凭证</p>
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/2.png" class="">

<p>从gitlab的设置中将 token复制过来</p>
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/3.png" class="">

<p>将复制的token粘贴到api token中，点ok</p>
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/4.png" class="">

<p>在系统配置中找到Gitlab 将信息进行填写，Credentials 选择刚刚创建对的即可</p>
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/6.png" class="">
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/5.png" class="">


<p>打开项目，编辑项目的构建触发器</p>
<p>配置触发条件，复制jenkins URL</p>
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/7.png" class="">

<p>生成Secret Token</p>
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/8.png" class="">


<h1 id="4、获取jenkins-用户token"><a href="#4、获取jenkins-用户token" class="headerlink" title="4、获取jenkins 用户token"></a>4、获取jenkins 用户token</h1><p>注意：jenkins用户的token只能是用户自己查看，就算是admin 也看不了</p>
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/9.png" class="">


<h1 id="5、配置gitlab"><a href="#5、配置gitlab" class="headerlink" title="5、配置gitlab"></a>5、配置gitlab</h1><p>URL 格式 ：<a href="http://username:api">http://username:api</a> token@jenkins调用url</p>
<p>secret token 就是之前jenkins project里面生成的</p>
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/10.png" class="">

<p>保存后 ，测试</p>
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/13.png" class="">


<p>返回200 表明成功，而且jenkins已经自动跑了</p>
<img src="/2018/07/09/2018-07-09-jenkins-gitlab-webhook/12.png" class="">







]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx动态限流</title>
    <url>/2018/07/10/2018-07-10-nginx-%E5%8A%A8%E6%80%81%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>动态限流一般是lua+redis,需要添加lua模块，或者把nginx直接替换为openresty.这个涉及到自己实现lua脚本，对于小白是有些难度的，这里利用第三方模块去实现，比lua要简单些，快速实现动态限流。</p>
<p>以下是nginx官方的第三方模块列表<br><a href="https://www.nginx.com/resources/wiki/modules/index.html" target="_blank" rel="noopener" title="NGINX 3rd Party Modules">NGINX 3rd Party Modules</a></p>
<p>我们使用<a href="https://github.com/limithit/ngx_dynamic_limit_req_module" target="_blank" rel="noopener">ngx_dynamic_limit_req_module</a>，配合redis实现动态限流</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>hiredis ： redis官方 C api<br>nginx   :  版本必须高于1.9.11.</p>
<h2 id="下载并编译hiredis"><a href="#下载并编译hiredis" class="headerlink" title="下载并编译hiredis"></a>下载并编译hiredis</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root hiredis]# wget https:&#x2F;&#x2F;github.com&#x2F;redis&#x2F;hiredis&#x2F;archive&#x2F;v0.13.3.tar.gz</span><br><span class="line">[root hiredis]# tar -zxf v0.13.3.tar.gz</span><br><span class="line">[root hiredis]# cd hiredis-0.13.3&#x2F;</span><br><span class="line">[root hiredis]# make</span><br><span class="line">[root hiredis]# make install</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;include&#x2F;hiredis &#x2F;usr&#x2F;local&#x2F;lib</span><br><span class="line">cp -a hiredis.h async.h read.h sds.h adapters &#x2F;usr&#x2F;local&#x2F;include&#x2F;hiredis</span><br><span class="line">cp -a libhiredis.so &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libhiredis.so.0.13</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;lib &amp;&amp; ln -sf libhiredis.so.0.13 libhiredis.so</span><br><span class="line">cp -a libhiredis.a &#x2F;usr&#x2F;local&#x2F;lib</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;lib&#x2F;pkgconfig</span><br><span class="line">cp -a hiredis.pc &#x2F;usr&#x2F;local&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>

<h2 id="下载并安装nginx"><a href="#下载并安装nginx" class="headerlink" title="下载并安装nginx"></a>下载并安装nginx</h2><p>因为原生nginx没有upstream检查，需要添加第三方模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;yaoweibin&#x2F;nginx_upstream_check_module&#x2F;archive&#x2F;master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure>
<p>开始安装nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.14.0.tar.gz</span><br><span class="line">tar -zxf nginx-1.14.0.tar.gz</span><br><span class="line">cd nginx-1.14.0&#x2F;</span><br><span class="line"> .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;pcre-8.42 --with-http_stub_status_module  --with-http_ssl_module --with-http_v2_module  --add-module&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;ngx_dynamic_limit_req_module-1.7 --add-module&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_upstream_check_module-master</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>检查hiredis是否安装成功，如果是not found,就建个软链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx|grep libhiredis</span><br><span class="line">libhiredis.so.0.13 &#x3D;&gt; not found (0x00007fd0fa245000)</span><br><span class="line">#查看之前生成的 so文件路径并软链</span><br><span class="line">&#x2F;lib&#x2F;libhiredis.so.0.13 -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libhiredis.so.0.13</span><br></pre></td></tr></table></figure>

<h2 id="这时候就可以装个redis了"><a href="#这时候就可以装个redis了" class="headerlink" title="这时候就可以装个redis了"></a>这时候就可以装个redis了</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install redis -y</span><br><span class="line">systemctl start redis</span><br></pre></td></tr></table></figure>

<h1 id="配置文件模板"><a href="#配置文件模板" class="headerlink" title="配置文件模板"></a>配置文件模板</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes  2;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    </span><br><span class="line">    dynamic_limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;100r&#x2F;s redis&#x3D;127.0.0.1 block_second&#x3D;300;</span><br><span class="line">    dynamic_limit_req_zone $binary_remote_addr zone&#x3D;two:10m rate&#x3D;50r&#x2F;s redis&#x3D;127.0.0.1 block_second&#x3D;600;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            dynamic_limit_req zone&#x3D;one burst&#x3D;5 nodelay;</span><br><span class="line">            dynamic_limit_req_status 403;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost2;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            dynamic_limit_req zone&#x3D;two burst&#x3D;5 nodelay;</span><br><span class="line">            dynamic_limit_req_status 403;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="支持黑白名单"><a href="#支持黑白名单" class="headerlink" title="支持黑白名单"></a>支持黑白名单</h2><h3 id="White-list-rules"><a href="#White-list-rules" class="headerlink" title="White list rules"></a>White list rules</h3><p>redis-cli set whiteip ip<br>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli set white192.168.1.1 192.168.1.1</span><br></pre></td></tr></table></figure>
<h3 id="Black-list-rules"><a href="#Black-list-rules" class="headerlink" title="Black list rules"></a>Black list rules</h3><p>redis-cli set ip ip<br>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli set 192.168.1.2 192.168.1.2</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>可以对具体的接口或者页面进行限流，而不用全局限制，block_second是锁定时间，单位为秒，这个时间可以自定义<br>参数也可以放到location里的if</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">         root   html;</span><br><span class="line">         index  index.html index.htm;</span><br><span class="line">          </span><br><span class="line">       if ($document_uri ~* &quot;index.php&quot;)&#123;          </span><br><span class="line">         dynamic_limit_req zone&#x3D;two burst&#x3D;5 nodelay;</span><br><span class="line">         dynamic_limit_req_status 403;</span><br><span class="line">              &#125;</span><br><span class="line">       if ( $args ~ l&#x3D;(.*)$) &#123;</span><br><span class="line">             dynamic_limit_req zone&#x3D;one burst&#x3D;5 nodelay;</span><br><span class="line">             dynamic_limit_req_status 403; </span><br><span class="line">             &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><p>提取apache ab命令单独使用，进行压测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">yumdownloader httpd-tools</span><br><span class="line">rpm2cpio httpd-tools-2.4.6-80.el7.centos.1.x86_64.rpm| cpio -idmv </span><br><span class="line">cd &#x2F;tmp&#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">cp ab &#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>关于kubelet 频繁du, 产生大量io</title>
    <url>/2018/07/16/2018-07-16-kubernetes-kubelet%E9%A2%91%E7%B9%81du-io%E8%BF%87%E9%AB%98/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用iotop查看io情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Total DISK READ :       9.79 M&#x2F;s | Total DISK WRITE :      24.66 K&#x2F;s</span><br><span class="line">Actual DISK READ:       8.21 M&#x2F;s | Actual DISK WRITE:       0.00 B&#x2F;s</span><br><span class="line">  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND                                                      </span><br><span class="line"> 5762 be&#x2F;7 root     1743.49 K&#x2F;s    0.00 B&#x2F;s  0.00 % 95.26 % du -s &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay&#x2F;e~61f203cd85d130b629268078be9c07f4</span><br><span class="line"> 5721 be&#x2F;7 root      750.23 K&#x2F;s    0.00 B&#x2F;s  0.00 % 94.64 % du -s &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay&#x2F;c~dd81ce0684eed62e983301a2bd67e694</span><br><span class="line">   41 be&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 % 52.87 % [kswapd0]</span><br><span class="line"> 5758 be&#x2F;7 root      200.77 K&#x2F;s    0.00 B&#x2F;s  0.00 % 34.72 % du -s &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay&#x2F;1~803fd9bf781dede9aad4c952530ff38c</span><br><span class="line"> 5761 be&#x2F;7 root      718.53 K&#x2F;s    0.00 B&#x2F;s  0.00 % 24.93 % du -s &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay&#x2F;3~bdb22e8d3cdf465e4a205b1ef72cbd49</span><br><span class="line"> 5759 be&#x2F;7 root      109.19 K&#x2F;s    0.00 B&#x2F;s  0.00 % 17.49 % du -s &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay&#x2F;3~be3fe72d2</span><br></pre></td></tr></table></figure>
<p>发现有好多进程在执行du命令占用了大量的磁盘io，仔细察看是kubelet在调用，kubelet在统计磁盘信息。</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>线上环境因为磁盘压力,空间不足的情况出现过大量Pod被驱逐的情形,导致节点上的Pod出现大量被驱逐状态</p>
<p><a href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/#evicting-end-user-pods" target="_blank" rel="noopener">k8s官方说明</a></p>
<p>k8s默认在磁盘小于10%的时候,就会evict pod,导致线上pod不能正常启动了</p>
<p>官方issue<br><a href="https://github.com/kubernetes/kubernetes/issues/23255" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/23255</a> </p>
<a id="more"></a>

<h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><ul>
<li>加大磁盘空间，尽量不触发du命令</li>
<li>或者更换ssd，减小io</li>
<li>还有一种是更换docker驱动overlay2，有待验证</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>配置shadowsocks服务端</title>
    <url>/2018/08/09/2018-08-09-%E9%85%8D%E7%BD%AEshadowscoks%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h1><p>以centos7 举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>

<hr>
<a id="more"></a>

<h1 id="配置shadowsocks"><a href="#配置shadowsocks" class="headerlink" title="配置shadowsocks"></a>配置shadowsocks</h1><p>shadowsocks有两种配置方法，一种是命令行参数配置，一种是配置文件。先来说说命令行配置</p>
<h2 id="命令行参数配置"><a href="#命令行参数配置" class="headerlink" title="命令行参数配置"></a>命令行参数配置</h2><p>命令行参数如下：<br>|参数名 | 参数意义|<br>|:–|:–|<br>|-s | 服务器地址<br>|-p | 服务器端口号<br>|-k    |服务器密码<br>|-m    |服务器加密方式<br>|-t    |服务器超时时间<br>|-c    |配置文件路径<br>|–fast-open    |快速打开模式，仅Unix/Linux系统可用<br>|–workers    |工作者数量</p>
<p>每次运行shadowsocks都将一大堆参数传进去是件很麻烦的事情。所以一般情况下都是采用配置文件的方式来配置的。然后通过-c参数将配置文件路径传入。</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>shadowsocks的配置文件是一个json形式的文件，各参数的意义和命令行参数意义相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;my_server_ip&quot;,</span><br><span class="line">    &quot;server_port&quot;:8388,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;mypassword&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器地址就写服务器的ip地址，不要写127.0.0.1。端口号可以自己写，但是不要占用其他服务的端口。本地地址和本地端口是客户端使用的，服务端可以不用理会。密码尽量采用复杂一点的密码，以保证安全性。加密方式使用aes-256-cfb就可以了。如果服务器是Linux系统的话，打开fast_open</p>
<p>配置文件编辑完毕之后，就可以运行shadowsocks了。前台运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks&#x2F;config.json</span><br></pre></td></tr></table></figure>
<p>后台运行和停止：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d start</span><br><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>
<p>以上都是在root用户下运行的。以root方式运行可能会有一些安全问题。所以一般都是使用普通用户运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json --user nobody -d start</span><br></pre></td></tr></table></figure>

<p>以上都需要自己手动运行命令来启动shadowsocks。要让shadowsocks在系统启动时自动运行，需要在/etc/rc.local中添加命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ssserver -c &#x2F;etc&#x2F;shadowsocks.json --user nobody -d start</span><br></pre></td></tr></table></figure>

<h1 id="shadowsocks优化"><a href="#shadowsocks优化" class="headerlink" title="shadowsocks优化"></a>shadowsocks优化</h1><h2 id="提高最大连接数"><a href="#提高最大连接数" class="headerlink" title="提高最大连接数"></a>提高最大连接数</h2><p>编辑/etc/security/limits.conf文件，添加以下两行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* soft nofile 51200</span><br><span class="line">* hard nofile 51200</span><br></pre></td></tr></table></figure>
<p>然后，在启动shadowsocks服务器之前，先设置一下ulimit：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -n 51200</span><br></pre></td></tr></table></figure>
<h2 id="调整内核参数"><a href="#调整内核参数" class="headerlink" title="调整内核参数"></a>调整内核参数</h2><p>调整内核参数的目标是：</p>
<ul>
<li>尽可能重用连接和端口号</li>
<li>尽可能增大队列和缓冲区</li>
<li>为高延迟和高流量选择合适的TCP拥塞算法</li>
</ul>
<p>下面是一个生产服务器的配置(/etc/sysctl.conf)，实例。如果不能使用，可能需要自己编译内核模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.file-max &#x3D; 51200</span><br><span class="line"></span><br><span class="line">net.core.rmem_max &#x3D; 67108864</span><br><span class="line">net.core.wmem_max &#x3D; 67108864</span><br><span class="line">net.core.netdev_max_backlog &#x3D; 250000</span><br><span class="line">net.core.somaxconn &#x3D; 4096</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1</span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 0</span><br><span class="line">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br><span class="line">net.ipv4.tcp_keepalive_time &#x3D; 1200</span><br><span class="line">net.ipv4.ip_local_port_range &#x3D; 10000 65000</span><br><span class="line">net.ipv4.tcp_max_syn_backlog &#x3D; 8192</span><br><span class="line">net.ipv4.tcp_max_tw_buckets &#x3D; 5000</span><br><span class="line">net.ipv4.tcp_fastopen &#x3D; 3</span><br><span class="line">net.ipv4.tcp_mem &#x3D; 25600 51200 102400</span><br><span class="line">net.ipv4.tcp_rmem &#x3D; 4096 87380 67108864</span><br><span class="line">net.ipv4.tcp_wmem &#x3D; 4096 65536 67108864</span><br><span class="line">net.ipv4.tcp_mtu_probing &#x3D; 1</span><br><span class="line">net.ipv4.tcp_congestion_control &#x3D; hybla</span><br></pre></td></tr></table></figure>
<p>修改之后需要运行sysctl -p来重载配置</p>
<h3 id="转载于"><a href="#转载于" class="headerlink" title="转载于###"></a>转载于###</h3><p><a href="https://blog.csdn.net/u011054333/article/details/52496303" target="_blank" rel="noopener">https://blog.csdn.net/u011054333/article/details/52496303</a></p>
<h1 id="docker-启动"><a href="#docker-启动" class="headerlink" title="docker 启动#"></a>docker 启动#</h1><p>有2个image可以选择<br>简单实用版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 1984:1984 oddrationale&#x2F;docker-shadowsocks -s 0.0.0.0 -p 1984 -k $SSPASSWORD -m aes-256-cfb</span><br></pre></td></tr></table></figure>

<p>持续更新，附加功能版(集成 kcptun、simple-obfs),具体参数可以查看hub.docker.com</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -dt --name ss -p 6443:6443 mritd&#x2F;shadowsocks -s &quot;-s 0.0.0.0 -p 6443 -m chacha20 -k test123 --fast-open&quot;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>GreateWall</tag>
      </tags>
  </entry>
  <entry>
    <title>kubeadm安装1.13</title>
    <url>/2018/12/27/2018-12-27-kubeadm%E5%AE%89%E8%A3%851.13/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>kubeadm 快速安装kubernetes集群，kubeadm 主要功能已经GA，除了高可用 还在alpha。功能如下图</p>
<table>
<thead>
<tr>
<th>Area</th>
<th>Maturity Level</th>
</tr>
</thead>
<tbody><tr>
<td>Command line UX</td>
<td>GA</td>
</tr>
<tr>
<td>Implementation</td>
<td>GA</td>
</tr>
<tr>
<td>Config file API</td>
<td>beta</td>
</tr>
<tr>
<td>CoreDNS</td>
<td>GA</td>
</tr>
<tr>
<td>kubeadm alpha subcommands</td>
<td>alpha</td>
</tr>
<tr>
<td>High availability</td>
<td>alpha</td>
</tr>
<tr>
<td>DynamicKubeletConfig</td>
<td>alpha</td>
</tr>
<tr>
<td>Self-hosting</td>
<td>alpha</td>
</tr>
</tbody></table>
<p>当前我们线上稳定运行的Kubernetes集群是使用pod形式部署的高可用集群，这里体验Kubernetes 1.13中的kubeadm是为了了解官方对集群初始化和配置方面的最佳方式</p>
<a id="more"></a>

<h1 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h1><h2 id="1-1系统配置"><a href="#1-1系统配置" class="headerlink" title="1.1系统配置"></a>1.1系统配置</h2><p>在安装之前，需要先做如下准备。三台CentOS 7.5主机如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/hosts</span><br><span class="line">192.168.1.57 master</span><br><span class="line">192.168.1.33 node1</span><br><span class="line">192.168.1.34 node2</span><br></pre></td></tr></table></figure>
<p>如果各个主机启用了防火墙，需要开放Kubernetes各个组件所需要的端口，可以查看Installing kubeadm中的”Check required ports”一节。 这里简单起见在各节点禁用防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>
<p>禁用SELINUX：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>
<p>创建/etc/sysctl.d/k8s.conf文件，添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>
<p>如果准备使用ipvs 模式node节点添加keepalive配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 30</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 10</span><br></pre></td></tr></table></figure>
<p>相关issue：<br><a href="https://github.com/moby/moby/issues/31208" target="_blank" rel="noopener">https://github.com/moby/moby/issues/31208</a></p>
<p>执行命令使修改生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe br_netfilter</span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure>
<p>##1.2kube-proxy开启ipvs的前置条件<br>由于ipvs已经加入到了内核的主干，所以为kube-proxy开启ipvs的前提需要加载以下的内核模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip_vs</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_sh</span><br><span class="line">nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<p>在所有的Kubernetes节点node1和node2上执行以下脚本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<p>上面脚本创建了的/etc/sysconfig/modules/ipvs.modules文件，保证在节点重启后能自动加载所需模块。 使用lsmod | grep -e ip_vs -e nf_conntrack_ipv4命令查看是否已经正确加载所需的内核模块。</p>
<p>接下来还需要确保各个节点上已经安装了ipset软件包yum install ipset。 为了便于查看ipvs的代理规则，最好安装一下管理工具ipvsadm yum install ipvsadm。</p>
<p>如果以上前提条件如果不满足，则即使kube-proxy的配置开启了ipvs模式，也会退回到iptables模式。</p>
<h2 id="1-3安装Docker"><a href="#1-3安装Docker" class="headerlink" title="1.3安装Docker"></a>1.3安装Docker</h2><p>Kubernetes从1.6开始使用CRI(Container Runtime Interface)容器运行时接口。默认的容器运行时仍然是Docker，使用的是kubelet中内置dockershim CRI实现。</p>
<p>安装docker的yum源:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>查看最新的Docker版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list docker-ce.x86_64  --showduplicates |sort -r</span><br><span class="line">docker-ce.x86_64            3:18.09.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.1.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.0.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.03.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.03.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.12.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.12.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.09.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.09.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.06.2.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.06.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.06.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.03.3.ce-1.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.03.2.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.03.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.03.0.ce-1.el7.centos             docker-ce-stable</span><br></pre></td></tr></table></figure>
<p>Kubernetes 1.12已经针对Docker的1.11.1, 1.12.1, 1.13.1, 17.03, 17.06, 17.09, 18.06等版本做了验证，需要注意Kubernetes 1.12最低支持的Docker版本是1.11.1。Kubernetes 1.13对Docker的版本依赖方面没有变化。</p>
<p>确认一下iptables filter表中FOWARD链的默认策略(pllicy)为ACCEPT。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -nvL</span><br><span class="line">Chain INPUT (policy ACCEPT 263 packets, 19209 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    0     0 DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">    0     0 DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">    0     0 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">    0     0 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">    0     0 ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">    0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>
<p>Docker从1.13版本开始调整了默认的防火墙规则，禁用了iptables filter表中FOWARD链，这样会引起Kubernetes集群中跨Node的Pod无法通信。docker在后面的18版本又改回来了。</p>
<h1 id="2-使用kubeadm部署Kubernetes"><a href="#2-使用kubeadm部署Kubernetes" class="headerlink" title="2.使用kubeadm部署Kubernetes"></a>2.使用kubeadm部署Kubernetes</h1><h2 id="2-1-安装kubeadm和kubelet"><a href="#2-1-安装kubeadm和kubelet" class="headerlink" title="2.1 安装kubeadm和kubelet"></a>2.1 安装kubeadm和kubelet</h2><p>下面在各节点安装kubeadm和kubelet：<br>使用阿里云k8s 仓，记得禁用check</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet-1.13.1 kubeadm-1.13.1 kubectl-1.13.1</span><br></pre></td></tr></table></figure>
<p>运行kubelet –help可以看到原来kubelet的绝大多数命令行flag参数都被DEPRECATED了,而官方推荐我们使用–config指定配置文件，并在配置文件中指定原来这些flag所配置的内容。具体内容可以查看这里<a href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/" target="_blank" rel="noopener">Set Kubelet parameters via a config file</a>。这也是Kubernetes为了支持动态Kubelet配置（Dynamic Kubelet Configuration）才这么做的，参考<a href="https://kubernetes.io/docs/tasks/administer-cluster/reconfigure-kubelet/" target="_blank" rel="noopener">Reconfigure a Node’s Kubelet in a Live Cluster</a>。</p>
<p>kubelet的配置文件必须是json或yaml格式，具体可查看这里。</p>
<p>Kubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动。</p>
<p>因为我的机器都开启了swap，关闭swap可能会对其他服务产生影响，所以这里修改kubelet的配置去掉这个限制。 之前的Kubernetes版本我们都是通过kubelet的启动参数–fail-swap-on=false去掉这个限制的。前面已经分析了Kubernetes不再推荐使用启动参数，而推荐使用配置文件。 所以这里我们改成配置文件配置的形式。</p>
<p>查看/etc/systemd/system/kubelet.service.d/10-kubeadm.conf，看到了下面的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Note: This dropin only works with kubeadm and kubelet v1.11+</span></span><br><span class="line">[Service]</span><br><span class="line">Environment="KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf"</span><br><span class="line">Environment="KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml"</span><br><span class="line"><span class="meta">#</span><span class="bash"> This is a file that <span class="string">"kubeadm init"</span> and <span class="string">"kubeadm join"</span> generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically</span></span><br><span class="line">EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env</span><br><span class="line"><span class="meta">#</span><span class="bash"> This is a file that the user can use <span class="keyword">for</span> overrides of the kubelet args as a last resort. Preferably, the user should use</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the .NodeRegistration.KubeletExtraArgs object <span class="keyword">in</span> the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.</span></span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kubelet</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS</span><br></pre></td></tr></table></figure>
<p>上面显示kubeadm部署的kubelet的配置文件–config=/var/lib/kubelet/config.yaml，实际去查看/var/lib/kubelet和这个config.yaml的配置文件都没有被创建。 可以猜想肯定是运行kubeadm初始化集群时会自动生成这个配置文件，而如果我们不关闭Swap的话，第一次初始化集群肯定会失败的。</p>
<p>所以还是老老实实的回到使用kubelet的启动参数–fail-swap-on=false去掉必须关闭Swap的限制。 修改/etc/sysconfig/kubelet，加入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">KUBELET_EXTRA_ARGS=--fail-swap-on=false</span><br></pre></td></tr></table></figure>

<h2 id="2-2-使用kubeadm-init初始化集群"><a href="#2-2-使用kubeadm-init初始化集群" class="headerlink" title="2.2 使用kubeadm init初始化集群"></a>2.2 使用kubeadm init初始化集群</h2><p>在各节点开机启动kubelet服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable kubelet.service</span><br></pre></td></tr></table></figure>

<p>因为默认初始镜像是gcr.io的，如果机器不翻墙是pull 不下来的，所以需要我们提前下载下来，并放到私有仓。</p>
<p>查看镜像版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm config images list</span><br><span class="line"></span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.13.1</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.13.1</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.13.1</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.13.1</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd:3.2.24</span><br><span class="line">k8s.gcr.io/coredns:1.2.6</span><br></pre></td></tr></table></figure>

<p>生成pull命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm config images list |sed -e 's/^/docker pull /g'</span><br></pre></td></tr></table></figure>

<p>下载镜像，并且上传到私有仓</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images|grep gcr.io|awk '&#123;print "docker tag ",$1":"$2,$1":"$2&#125;'|sed 's#k8s.gcr.io#docker.foxchan.com/google_containers#2'</span><br><span class="line"></span><br><span class="line">docker tag  k8s.gcr.io/kube-proxy:v1.13.1 docker.foxchan.com/google_containers/kube-proxy:v1.13.1</span><br><span class="line">docker tag  k8s.gcr.io/kube-apiserver:v1.13.1 docker.foxchan.com/google_containers/kube-apiserver:v1.13.1</span><br><span class="line">docker tag  k8s.gcr.io/kube-controller-manager:v1.13.1 docker.foxchan.com/google_containers/kube-controller-manager:v1.13.1</span><br><span class="line">docker tag  k8s.gcr.io/kube-scheduler:v1.13.1 docker.foxchan.com/google_containers/kube-scheduler:v1.13.1</span><br><span class="line">docker tag  k8s.gcr.io/etcd:3.2.24 docker.foxchan.com/google_containers/etcd:3.2.24</span><br><span class="line">docker tag  k8s.gcr.io/coredns:1.2.6 docker.foxchan.com/google_containers/coredns:1.2.6</span><br><span class="line">docker tag  k8s.gcr.io/pause:3.1 docker.foxchan.com/google_containers/pause:3.1</span><br></pre></td></tr></table></figure>
<h3 id="2-2-1通过配置文件安装"><a href="#2-2-1通过配置文件安装" class="headerlink" title="2.2.1通过配置文件安装"></a>2.2.1通过配置文件安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm config print init-defaults &gt;kubeadm.conf</span><br></pre></td></tr></table></figure>
<p>将配置文件的imageRepository: 修改为自己的私有仓<br>imageRepository: docker.emarbox.com/google_containers</p>
<p>kubernetesVersion 改为自有版本<br>kubernetesVersion: v1.13.1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm config images list --config kubeadm.conf</span><br><span class="line">kubeadm config images pull --config kubeadm.conf</span><br><span class="line">kubeadm init --config kubeadm.conf</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-通过参数化安装"><a href="#2-2-2-通过参数化安装" class="headerlink" title="2.2.2 通过参数化安装"></a>2.2.2 通过参数化安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">   --kubernetes-version=v1.13.1 \</span><br><span class="line">   --pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">   --apiserver-advertise-address=101.254.242.57 \</span><br><span class="line">   --ignore-preflight-errors=Swap \</span><br><span class="line">   --token-ttl 0 \</span><br><span class="line">   --image-repository docker.emarbox.com/google_containers</span><br></pre></td></tr></table></figure>

<p>–token-ttl 0  初始化的时候指定token不过期<br>如果token过期了，用以下步骤重新生成<br>创建新的token </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm token create</span><br></pre></td></tr></table></figure>
<p>获取ca证书sha256编码hash值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'</span><br></pre></td></tr></table></figure>


<p>因为我们选择flannel作为Pod网络插件，所以上面的命令指定–pod-network-cidr=10.244.0.0/16。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[init] Using Kubernetes version: v1.13.1</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING Swap]: running with swap on is not supported. Please disable swap</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[certs] Using certificateDir folder "/etc/kubernetes/pki"</span><br><span class="line">[certs] Generating "ca" certificate and key</span><br><span class="line">[certs] Generating "apiserver-kubelet-client" certificate and key</span><br><span class="line">[certs] Generating "apiserver" certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [node1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.61.11]</span><br><span class="line">[certs] Generating "front-proxy-ca" certificate and key</span><br><span class="line">[certs] Generating "front-proxy-client" certificate and key</span><br><span class="line">[certs] Generating "etcd/ca" certificate and key</span><br><span class="line">[certs] Generating "etcd/healthcheck-client" certificate and key</span><br><span class="line">[certs] Generating "etcd/server" certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [node1 localhost] and IPs [192.168.61.11 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating "etcd/peer" certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [node1 localhost] and IPs [192.168.61.11 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating "apiserver-etcd-client" certificate and key</span><br><span class="line">[certs] Generating "sa" key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder "/etc/kubernetes"</span><br><span class="line">[kubeconfig] Writing "admin.conf" kubeconfig file</span><br><span class="line">[kubeconfig] Writing "kubelet.conf" kubeconfig file</span><br><span class="line">[kubeconfig] Writing "controller-manager.conf" kubeconfig file</span><br><span class="line">[kubeconfig] Writing "scheduler.conf" kubeconfig file</span><br><span class="line">[control-plane] Using manifest folder "/etc/kubernetes/manifests"</span><br><span class="line">[control-plane] Creating static Pod manifest for "kube-apiserver"</span><br><span class="line">[control-plane] Creating static Pod manifest for "kube-controller-manager"</span><br><span class="line">[control-plane] Creating static Pod manifest for "kube-scheduler"</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 19.506551 seconds</span><br><span class="line">[uploadconfig] storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap "kubelet-config-1.13" in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[patchnode] Uploading the CRI Socket information "/var/run/dockershim.sock" to the Node API object "node1" as an annotation</span><br><span class="line">[mark-control-plane] Marking the node node1 as control-plane by adding the label "node-role.kubernetes.io/master=''"</span><br><span class="line">[mark-control-plane] Marking the node node1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: 702gz5.49zhotgsiyqimwqw</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstraptoken] creating the "cluster-info" ConfigMap in the "kube-public" namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join 192.168.1.57:6443 --token pm5kht.s9fh59lop2m34ge9 --discovery-token-ca-cert-hash sha256:9c0f2cc3ab7c2a4bee0532952600befc0e2faf02794c23fa6227870fef18b18a \</span><br><span class="line">  --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure>
<p>上面记录了完成的初始化输出的内容，根据输出的内容基本上可以看出手动初始化安装一个Kubernetes集群所需要的关键步骤。</p>
<p>其中有以下关键内容：</p>
<ul>
<li>[kubelet-start] 生成kubelet的配置文件”/var/lib/kubelet/config.yaml”</li>
<li>[certificates]生成相关的各种证书</li>
<li>[kubeconfig]生成相关的kubeconfig文件</li>
<li>[bootstraptoken]生成token记录下来，后边使用kubeadm join往集群中添加节点时会用到</li>
<li>下面的命令是配置常规用户如何使用kubectl访问集群：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>
最后给出了将节点加入集群的命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.1.57:6443 --token pm5kht.s9fh59lop2m34ge9 --discovery-token-ca-cert-hash sha256:9c0f2cc3ab7c2a4bee0532952600befc0e2faf02794c23fa6227870fef18b18a --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>查看一下集群状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get cs</span><br><span class="line">NAME                 STATUS    MESSAGE              ERROR</span><br><span class="line">controller-manager   Healthy   ok</span><br><span class="line">scheduler            Healthy   ok</span><br><span class="line">etcd-0               Healthy   &#123;"health": "true"&#125;</span><br></pre></td></tr></table></figure>
<p>确认个组件都处于healthy状态。</p>
<p>集群初始化如果遇到问题，可以使用下面的命令进行清理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm reset</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">rm -rf /var/lib/cni/</span><br></pre></td></tr></table></figure>

<p>##2.3 安装Pod Network<br>接下来安装flannel network add-on：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/kubernetes/addons/</span><br><span class="line">cd addons/</span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">kubectl apply -f  kube-flannel.yml</span><br><span class="line"></span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-amd64 created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-arm64 created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-arm created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-ppc64le created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-s390x created</span><br></pre></td></tr></table></figure>
<p>这里注意kube-flannel.yml这个文件里的flannel的镜像是0.10.0，quay.io/coreos/flannel:v0.10.0-amd64</p>
<p>如果Node有多个网卡的话，参考flannel issues 39701，目前需要在kube-flannel.yml中使用–iface参数指定集群主机内网网卡的名称，否则可能会出现dns无法解析。需要将kube-flannel.yml下载到本地，flanneld启动参数加上–iface=<iface-name></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">containers:</span><br><span class="line">      - name: kube-flannel</span><br><span class="line">        image: quay.io/coreos/flannel:v0.10.0-amd64</span><br><span class="line">        command:</span><br><span class="line">        - /opt/bin/flanneld</span><br><span class="line">        args:</span><br><span class="line">        - --ip-masq</span><br><span class="line">        - --kube-subnet-mgr</span><br><span class="line">        - --iface=eth1</span><br></pre></td></tr></table></figure>
<p>使用kubectl get pod –all-namespaces -o wide确保所有的Pod都处于Running状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod --all-namespaces -o wide</span><br><span class="line">NAMESPACE       NAME                                            READY   STATUS    RESTARTS   AGE     IP               NODE             NOMINATED NODE   READINESS GATES</span><br><span class="line">default         curl-66959f6557-9dv5g                           1/1     Running   1          6d3h    10.244.0.4       192.168.1.57     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx   nginx-ingress-controller-79b7dccb-6t2nr         1/1     Running   0          3d3h    10.244.2.15      192.168.1.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx   nginx-ingress-controller-79b7dccb-r7ljd         1/1     Running   0          3d3h    10.244.1.29      192.168.1.33   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx   nginx-ingress-default-backend-759456dbc-8nrsf   1/1     Running   0          3d3h    10.244.1.28      192.168.1.33   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     coredns-5fcfdd4ccd-9bk7q                        1/1     Running   0          6d20h   10.244.0.2       192.168.1.57     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     coredns-5fcfdd4ccd-dzw89                        1/1     Running   0          6d20h   10.244.0.3       192.168.1.57     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     etcd-192.168.1.57                               1/1     Running   0          6d20h   192.168.1.57   192.168.1.57     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     kube-apiserver-192.168.1.57                     1/1     Running   0          6d20h   192.168.1.57   192.168.1.57     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     kube-controller-manager-192.168.1.57            1/1     Running   0          6d20h   192.168.1.57   192.168.1.57     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     kube-flannel-ds-amd64-226tp                     1/1     Running   0          6d      192.168.1.33   192.168.1.33   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     kube-flannel-ds-amd64-7r74j                     1/1     Running   0          6d      192.168.1.34   192.168.1.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     kube-flannel-ds-amd64-rxzms                     1/1     Running   0          6d3h    192.168.1.57   192.168.1.57     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     kube-proxy-5r4mg                                1/1     Running   0          5d23h   192.168.1.34   192.168.1.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     kube-proxy-82867                                1/1     Running   0          5d23h   192.168.1.33   192.168.1.33   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     kube-proxy-hqgkw                                1/1     Running   0          5d23h   192.168.1.57   192.168.1.57     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     kube-scheduler-192.168.1.57                     1/1     Running   0          6d20h   192.168.1.57   192.168.1.57     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system     tiller-deploy-84bcb9978c-2blph                  1/1     Running   0          3d3h    10.244.2.13      192.168.1.34   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-master-node参与工作负载"><a href="#2-4-master-node参与工作负载" class="headerlink" title="2.4 master node参与工作负载"></a>2.4 master node参与工作负载</h2><p>使用kubeadm初始化的集群，出于安全考虑Pod不会被调度到Master Node上，也就是说Master Node不参与工作负载。这是因为当前的master节点node1被打上了node-role.kubernetes.io/master:NoSchedule的污点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl describe node node1 | grep Taint</span><br><span class="line">Taints:             node-role.kubernetes.io/master:NoSchedule</span><br></pre></td></tr></table></figure>
<p>因为这里搭建的是测试环境，去掉这个污点使node1参与工作负载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes node1 node-role.kubernetes.io/master-</span><br><span class="line">node "node1" untainted</span><br></pre></td></tr></table></figure>
<h2 id="2-5-测试DNS"><a href="#2-5-测试DNS" class="headerlink" title="2.5 测试DNS"></a>2.5 测试DNS</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl run curl --image=radial/busyboxplus:curl -it</span><br><span class="line">kubectl run --generator=deployment/apps.v1beta1 is DEPRECATED and will be removed in a future version. Use kubectl create instead.</span><br><span class="line">If you don't see a command prompt, try pressing enter.</span><br><span class="line">[ root@curl-5cc7b478b6-r997p:/ ]$</span><br></pre></td></tr></table></figure>
<p>进入后执行nslookup kubernetes.default确认解析正常:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup kubernetes.default</span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      kubernetes.default</span><br><span class="line">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</span><br></pre></td></tr></table></figure>
<h2 id="2-6-向Kubernetes集群中添加Node节点"><a href="#2-6-向Kubernetes集群中添加Node节点" class="headerlink" title="2.6 向Kubernetes集群中添加Node节点"></a>2.6 向Kubernetes集群中添加Node节点</h2><p>优先级：<br>/etc/sysconfig/kubelet 参数高于/var/lib/kubelet/config.yaml<br>这里修改上报节点name为ip,修改kubelet</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">KUBELET_EXTRA_ARGS=-<span class="literal">-fail</span><span class="literal">-swap</span><span class="literal">-on</span>=false -<span class="literal">-hostname</span><span class="literal">-override</span>=<span class="number">192.168</span>.<span class="number">1.33</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>
<p>下面我们将node2这个主机添加到Kubernetes集群中，因为我们同样在node2上的kubelet的启动参数中去掉了必须关闭swap的限制，所以同样需要–ignore-preflight-errors=Swap这个参数。 在node2上执行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.1.57:6443 --token 702gz5.49zhotgsiyqimwqw --discovery-token-ca-cert-hash sha256:2bc50229343849e8021d2aa19d9d314539b40ec7a311b5bb6ca1d3cd10957c2f \</span><br><span class="line"> --ignore-preflight-errors=Swap</span><br><span class="line"></span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING Swap]: running with swap on is not supported. Please disable swap</span><br><span class="line">[discovery] Trying to connect to API Server "192.168.1.57:6443"</span><br><span class="line">[discovery] Created cluster-info discovery client, requesting info from "https://192.168.61.11:6443"</span><br><span class="line">[discovery] Requesting info from "https://192.168.1.57:6443" again to validate TLS against the pinned public key</span><br><span class="line">[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server "192.168.1.57:6443"</span><br><span class="line">[discovery] Successfully established connection with API Server "192.168.1.57:6443"</span><br><span class="line">[join] Reading configuration from the cluster...</span><br><span class="line">[join] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml'</span><br><span class="line">[kubelet] Downloading configuration for the kubelet from the "kubelet-config-1.13" ConfigMap in the kube-system namespace</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[tlsbootstrap] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line">[patchnode] Uploading the CRI Socket information "/var/run/dockershim.sock" to the Node API object "node2" as an annotation</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run 'kubectl get nodes' on the master to see this node join the cluster.</span><br></pre></td></tr></table></figure>
<p>node2加入集群很是顺利，下面在master节点上执行命令查看集群中的节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">NAME             STATUS   ROLES    AGE     VERSION</span><br><span class="line">192.168.1.33   Ready    edge     6d      v1.13.1</span><br><span class="line">192.168.1.34   Ready    edge     6d      v1.13.1</span><br><span class="line">192.168.1.57     Ready    master   6d20h   v1.13.1</span><br></pre></td></tr></table></figure>
<p>如何从集群中移除Node<br>如果需要从集群中移除node2这个Node执行下面的命令：</p>
<p>在master节点上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl drain node2 --delete-local-data --force --ignore-daemonsets</span><br><span class="line">kubectl delete node node2</span><br></pre></td></tr></table></figure>
<p>在node2上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm reset</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">rm -rf /var/lib/cni/</span><br></pre></td></tr></table></figure>
<p>在master上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete node node2</span><br></pre></td></tr></table></figure>
<h2 id="2-7-kube-proxy开启ipvs"><a href="#2-7-kube-proxy开启ipvs" class="headerlink" title="2.7 kube-proxy开启ipvs"></a>2.7 kube-proxy开启ipvs</h2><p>修改ConfigMap的kube-system/kube-proxy中的config.conf，mode: “ipvs”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl edit cm kube-proxy -n kube-system</span><br></pre></td></tr></table></figure>
<p>之后重启各个节点上的kube-proxy pod：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system | grep kube-proxy | awk &#39;&#123;system(&quot;kubectl delete pod &quot;$1&quot; -n kube-system&quot;)&#125;&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system | grep kube-proxy</span><br><span class="line">kube-proxy-pf55q                1&#x2F;1     Running   0          9s</span><br><span class="line">kube-proxy-qjnnc                1&#x2F;1     Running   0          14s</span><br><span class="line"></span><br><span class="line">kubectl logs kube-proxy-pf55q -n kube-system</span><br><span class="line">I1208 06:12:23.516444       1 server_others.go:189] Using ipvs Proxier.</span><br><span class="line">W1208 06:12:23.516738       1 proxier.go:365] IPVS scheduler not specified, use rr by default</span><br><span class="line">I1208 06:12:23.516840       1 server_others.go:216] Tearing down inactive rules.</span><br><span class="line">I1208 06:12:23.575222       1 server.go:464] Version: v1.13.0</span><br><span class="line">I1208 06:12:23.585142       1 conntrack.go:52] Setting nf_conntrack_max to 131072</span><br><span class="line">I1208 06:12:23.586203       1 config.go:202] Starting service config controller</span><br><span class="line">I1208 06:12:23.586243       1 controller_utils.go:1027] Waiting for caches to sync for service config controller</span><br><span class="line">I1208 06:12:23.586269       1 config.go:102] Starting endpoints config controller</span><br><span class="line">I1208 06:12:23.586275       1 controller_utils.go:1027] Waiting for caches to sync for endpoints config controller</span><br><span class="line">I1208 06:12:23.686959       1 controller_utils.go:1034] Caches are synced for endpoints config controller</span><br><span class="line">I1208 06:12:23.687056       1 controller_utils.go:1034] Caches are synced for service config controller</span><br></pre></td></tr></table></figure>
<p>日志中打印出了Using ipvs Proxier，说明ipvs模式已经开启。</p>
<p>#3.Kubernetes常用组件部署<br>越来越多的公司和团队开始使用Helm这个Kubernetes的包管理器，我们也将使用Helm安装Kubernetes的常用组件。</p>
<h2 id="3-1-Helm的安装"><a href="#3-1-Helm的安装" class="headerlink" title="3.1 Helm的安装"></a>3.1 Helm的安装</h2><p>Helm由客户端命helm令行工具和服务端tiller组成，Helm的安装十分简单。 下载helm命令行工具到master节点node1的/usr/local/bin下，这里下载的2.12.0版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;storage.googleapis.com&#x2F;kubernetes-helm&#x2F;helm-v2.12.0-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf helm-v2.12.0-linux-amd64.tar.gz</span><br><span class="line">cd linux-amd64&#x2F;</span><br><span class="line">cp helm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>

<p>因为Kubernetes APIServer开启了RBAC访问控制，所以需要创建tiller使用的service account: tiller并分配合适的角色给它。 详细内容可以查看helm文档中的Role-based Access Control。 这里简单起见直接分配cluster-admin这个集群内置的ClusterRole给它。创建rbac-config.yaml文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: tiller</span><br><span class="line">    namespace: kube-system</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create -f rbac-config.yaml</span><br><span class="line">serviceaccount&#x2F;tiller created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io&#x2F;tiller created</span><br></pre></td></tr></table></figure>
<p>接下来使用helm部署tiller:<br>使用阿里云镜像，并指定repo为阿里云</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm init --upgrade -i registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;tiller:v2.12.0 --stable-repo-url https:&#x2F;&#x2F;kubernetes.oss-cn-hangzhou.aliyuncs.com&#x2F;charts</span><br></pre></td></tr></table></figure>
<p>tiller默认被部署在k8s集群中的kube-system这个namespace下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system -l app&#x3D;helm</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">tiller-deploy-c4fd4cd68-dwkhv   1&#x2F;1     Running   0          83s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm version</span><br><span class="line">Client: &amp;version.Version&#123;SemVer:&quot;v2.12.0&quot;, GitCommit:&quot;d325d2a9c179b33af1a024cdb5a4472b6288016a&quot;, GitTreeState:&quot;clean&quot;&#125;</span><br><span class="line">Server: &amp;version.Version&#123;SemVer:&quot;v2.12.0&quot;, GitCommit:&quot;d325d2a9c179b33af1a024cdb5a4472b6288016a&quot;, GitTreeState:&quot;clean&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>注意由于某些原因需要网络可以访问gcr.io和kubernetes-charts.storage.googleapis.com，如果无法访问可以通过helm init –service-account tiller –tiller-image <your-docker-registry>/tiller:v2.11.0 –skip-refresh使用私有镜像仓库中的tiller镜像</p>
<h2 id="3-2-使用Helm部署Nginx-Ingress"><a href="#3-2-使用Helm部署Nginx-Ingress" class="headerlink" title="3.2 使用Helm部署Nginx Ingress"></a>3.2 使用Helm部署Nginx Ingress</h2><p>为了便于将集群中的服务暴露到集群外部，从集群外部访问，接下来使用Helm将Nginx Ingress部署到Kubernetes上。 Nginx Ingress Controller被部署在Kubernetes的边缘节点上，关于Kubernetes边缘节点的高可用相关的内容可以查看我前面整理的Bare metal环境下Kubernetes Ingress边缘节点的高可用(基于IPVS)。</p>
<p>我们将node1(192.168.1.33)和node2(192.168.1.34)同时做为边缘节点，打上Label：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl label node 192.168.1.33 node-role.kubernetes.io&#x2F;edge&#x3D;</span><br><span class="line">node&#x2F;node1 labeled</span><br><span class="line"></span><br><span class="line">kubectl label node 192.168.1.34 node-role.kubernetes.io&#x2F;edge&#x3D;</span><br><span class="line">node&#x2F;node2 labeled</span><br><span class="line"></span><br><span class="line">kubectl get node</span><br><span class="line">NAME             STATUS   ROLES    AGE     VERSION</span><br><span class="line">192.168.1.33   Ready    edge     6d      v1.13.1</span><br><span class="line">192.168.1.34   Ready    edge     6d      v1.13.1</span><br><span class="line">192.168.1.57     Ready    master   6d20h   v1.13.1</span><br></pre></td></tr></table></figure>
<p>stable/nginx-ingress chart的值文件ingress-nginx.yaml：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">controller:</span><br><span class="line">  replicaCount: 2</span><br><span class="line">  service:</span><br><span class="line">    externalIPs:</span><br><span class="line">      - 192.168.1.68</span><br><span class="line">  nodeSelector:</span><br><span class="line">    node-role.kubernetes.io/edge: ''</span><br><span class="line">  affinity:</span><br><span class="line">    podAntiAffinity:</span><br><span class="line">        requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        - labelSelector:</span><br><span class="line">            matchExpressions:</span><br><span class="line">            - key: app </span><br><span class="line">              operator: In</span><br><span class="line">              values:</span><br><span class="line">              - nginx-ingress</span><br><span class="line">            - key: component</span><br><span class="line">              operator: In</span><br><span class="line">              values:</span><br><span class="line">              - controller</span><br><span class="line">          topologyKey: kubernetes.io/hostname</span><br><span class="line">  tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io/master</span><br><span class="line">        operator: Exists</span><br><span class="line">        effect: NoSchedule</span><br><span class="line"></span><br><span class="line">defaultBackend:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    node-role.kubernetes.io/edge: ''</span><br><span class="line">  tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io/master</span><br><span class="line">        operator: Exists</span><br><span class="line">        effect: NoSchedule</span><br></pre></td></tr></table></figure>
<p>nginx ingress controller的副本数replicaCount为2，将被调度到node1和node2这两个边缘节点上。externalIPs指定的192.168.1.68为VIP，将绑定到kube-proxy kube-ipvs0网卡上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install stable/nginx-ingress -n nginx-ingress --namespace ingress-nginx  -f ingress-nginx.yaml --set rbac.create=true</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n ingress-nginx -o wide</span><br><span class="line">NAME                                            READY   STATUS    RESTARTS   AGE    IP            NODE             NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-ingress-controller-79b7dccb-6t2nr         1/1     Running   0          3d3h   10.244.2.15   192.168.1.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-ingress-controller-79b7dccb-r7ljd         1/1     Running   0          3d3h   10.244.1.29   192.168.1.33   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-ingress-default-backend-759456dbc-8nrsf   1/1     Running   0          3d3h   10.244.1.28   192.168.1.33   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>如果访问<a href="http://192.168.1.68返回default" target="_blank" rel="noopener">http://192.168.1.68返回default</a> backend，则部署完成。</p>
<p>注意：这里的VIP68,只能从k8s集群的node才能访问。</p>
<p>实际测试的结果是无法访问，于是怀疑kube-proxy出了问题，查看kube-proxy的日志，不停的刷下面的log：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">I1208 07:59:28.902970       1 graceful_termination.go:160] Trying to delete rs: 10.104.110.193:80/TCP/10.244.1.5:80</span><br><span class="line">I1208 07:59:28.903037       1 graceful_termination.go:170] Deleting rs: 10.104.110.193:80/TCP/10.244.1.5:80</span><br><span class="line">I1208 07:59:28.903072       1 graceful_termination.go:160] Trying to delete rs: 10.104.110.193:80/TCP/10.244.0.6:80</span><br><span class="line">I1208 07:59:28.903105       1 graceful_termination.go:170] Deleting rs: 10.104.110.193:80/TCP/10.244.0.6:80</span><br><span class="line">I1208 07:59:28.903713       1 graceful_termination.go:160] Trying to delete rs: 192.168.61.10:80/TCP/10.244.1.5:80</span><br><span class="line">I1208 07:59:28.903764       1 graceful_termination.go:170] Deleting rs: 192.168.61.10:80/TCP/10.244.1.5:80</span><br><span class="line">I1208 07:59:28.903798       1 graceful_termination.go:160] Trying to delete rs: 192.168.61.10:80/TCP/10.244.0.6:80</span><br><span class="line">I1208 07:59:28.903824       1 graceful_termination.go:170] Deleting rs: 192.168.61.10:80/TCP/10.244.0.6:80</span><br><span class="line">I1208 07:59:28.904654       1 graceful_termination.go:160] Trying to delete rs: 10.0.2.15:31698/TCP/10.244.0.6:80</span><br><span class="line">I1208 07:59:28.904837       1 graceful_termination.go:170] Deleting rs: 10.0.2.15:31698/TCP/10.244.0.6:80</span><br></pre></td></tr></table></figure>
<p>在Kubernetes的Github上找到了这个ISSUE <a href="https://github.com/kubernetes/kubernetes/issues/71071，大致是最近更新的IPVS" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/71071，大致是最近更新的IPVS</a> proxier mode now support connection based graceful termination.引入了bug，导致Kubernetes的1.11.5、1.12.1~1.12.3、1.13.0都有这个问题，即kube-proxy在ipvs模式下不可用。而官方称在1.11.5、1.12.3、1.13.0中修复了12月4日k8s的特权升级漏洞(CVE-2018-1002105)，如果针对这个漏洞做k8s升级的同学，需要小心，确认是否开启了ipvs，避免由升级引起k8s网络问题。由于我们线上的版本是1.11并且已经启用了ipvs，所以这里我们只能先把线上master node升级到了1.11.5，而kube-proxy还在使用1.11.4的版本。</p>
<p><a href="https://github.com/kubernetes/kubernetes/issues/71071中已经描述有相关PR解决这个问题，后续只能跟踪一下1.11.5、1.12.3、1.13.0之后的小版本了。" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/71071中已经描述有相关PR解决这个问题，后续只能跟踪一下1.11.5、1.12.3、1.13.0之后的小版本了。</a></p>
<p>查看kube-proxy日志，<a href="https://github.com/kubernetes/kubernetes/issues/71071的问题依旧。" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/71071的问题依旧。</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello HEXO</title>
    <url>/2020/07/23/2020-07-07-hello-world/</url>
    <content><![CDATA[<h1 id="记录下blog服务变化"><a href="#记录下blog服务变化" class="headerlink" title="记录下blog服务变化"></a>记录下blog服务变化</h1><p>迁移blog 到hexo</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
